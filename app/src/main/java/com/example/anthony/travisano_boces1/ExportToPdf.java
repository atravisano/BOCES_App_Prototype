package com.example.anthony.travisano_boces1;


import android.content.Context;
import android.os.Environment;
import android.util.Log;

import com.itextpdf.text.BadElementException;
import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.Font;
import com.itextpdf.text.Paragraph;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPTable;
import com.itextpdf.text.pdf.PdfWriter;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.io.File;
import java.io.FileOutputStream;
import java.util.Locale;

/**
 * Author: Anthony Travisano
 * Purpose: Creates pdf file of the student's report
 *      Report includes range of report and two tables
 *      A table of all students that clocked in
 *      A table of all students total work time for range selected
 * Date: 12/13/17
 */

public class ExportToPdf {
    Context context;
    private ArrayList<Work> workList;
    private ArrayList<Work> totalTimeList;
    private String startDate;
    private String endDate;
    //boolean to determine whether to include all student clock ins
    private boolean clockIns;

    //The pdf file is saved in a directory called BOCES with the title and date it was created
    private  String FILE = Environment.getExternalStorageDirectory() + "/BOCES/Student Work Report " + DateFormat.getDateTimeInstance().format(new Date())+ ".pdf";
    private  Font catFont = new Font(Font.FontFamily.TIMES_ROMAN, 18,
            Font.BOLD);
    private  Font redFont = new Font(Font.FontFamily.TIMES_ROMAN, 12,
            Font.NORMAL, BaseColor.RED);
    private  Font subFont = new Font(Font.FontFamily.TIMES_ROMAN, 16,
            Font.BOLD);
    private  Font smallBold = new Font(Font.FontFamily.TIMES_ROMAN, 12,
            Font.BOLD);

    ExportToPdf(Context c, ArrayList<Work> workList) {
        context = c;
        this.workList = workList;
    }
    ExportToPdf(Context c, ArrayList<Work> workList, String startDate, String endDate) {
        context = c;
        this.workList = workList;
        this.setStartDate(startDate);
        this.setEndDate(endDate);
    }

    public  String getStartDate() {
        return startDate;
    }

    public  void setStartDate(String startDate) {
        this.startDate = startDate;
    }

    public  String getEndDate() {
        return endDate;
    }

    public  void setEndDate(String endDate) {this.endDate = endDate;
    }

    //all methods used to completely create pdf document
    public void createPdf() {
        try {
            Document document = new Document();
            createDirectory();
            PdfWriter.getInstance(document, new FileOutputStream(FILE));
            document.open();
            addMetaData(document);
            addTitlePage(document);
            addContent(document);
            document.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    //creates a directory for pdf files if one does not exist
    private  void createDirectory() {
        File myDirectory = new File(Environment.getExternalStorageDirectory(), "BOCES");
        if(!myDirectory.exists()) {
            myDirectory.mkdirs();
            Log.d("ExportToPdf","Directory Created");
        }
        else
            Log.d("ExportToPdf","Directory Not Created");
    }

    // iText allows to add metadata to the PDF which can be viewed in your Adobe
    // Reader
    // under File -> Properties
    private  void addMetaData(Document document) {
        document.addTitle("Student Work Report");
        document.addSubject("Students Work");
        document.addKeywords("Work, PDF, Student");
        document.addAuthor(System.getProperty("user.name"));
        document.addCreator(System.getProperty("user.name"));
    }

    //Creates Title of pdf and header information
    private  void addTitlePage(Document document)
            throws DocumentException {
        Paragraph preface = new Paragraph();
        // We add one empty line
        addEmptyLine(preface, 1);
        // Lets write a big header
        preface.add(new Paragraph("Work Report", catFont));

        addEmptyLine(preface, 1);
        // Will create: Report generated by: _name, _date
        preface.add(new Paragraph(
                "Report generated by: " + System.getProperty("user.name") + ", " + new Date(), //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                smallBold));
        addEmptyLine(preface, 2);
        preface.add(new Paragraph(
                "Report Date Range: From " + startDate + " To " + endDate,
                smallBold));
        addEmptyLine(preface, 3);
        document.add(preface);
    }

    //adds the two tables and sorts workList
    private  void addContent(Document document) throws DocumentException, ParseException {
        Paragraph clockIn = new Paragraph();
        addEmptyLine(clockIn, 1);

        //sorts the worklist by the user selected date range
        sortByDateRange();
        // add a table of all students that clocked in if user requests it
        if(isClockIns()) {
            // header
            clockIn.add(new Paragraph("All Clock Ins", catFont));
            createClockInTable(clockIn);
        }
        addEmptyLine(clockIn, 1);
        // now add all this to the document
        document.add(clockIn);
        // Next section
        Paragraph totalTimes = new Paragraph();
        addEmptyLine(totalTimes, 1);
        //header
        totalTimes.add(new Paragraph("Total Times", catFont));
        addEmptyLine(totalTimes, 1);
        //add table of student's total time working
        createTotalsTable(totalTimes);
        document.add(totalTimes);
    }

    //creates the student clock in table
    private  void createClockInTable(Paragraph subCatPart)
            throws BadElementException {
        PdfPTable table = new PdfPTable(7);
    PdfPCell c1 = new PdfPCell(new Phrase("Work ID"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

    c1 = new PdfPCell(new Phrase("Student Name"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

    c1 = new PdfPCell(new Phrase("Student ID"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        c1 = new PdfPCell(new Phrase("Task Name"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        c1 = new PdfPCell(new Phrase("Time Started"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        c1 = new PdfPCell(new Phrase("Time Stopped"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        c1 = new PdfPCell(new Phrase("Time Worked"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        addWorkInfo(table);

        subCatPart.add(table);

    }

    //creates student total time table
    private  void createTotalsTable(Paragraph subCatPart)
            throws BadElementException {
        PdfPTable table = new PdfPTable(3);

        PdfPCell c1 = new PdfPCell(new Phrase("Student ID"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        c1 = new PdfPCell(new Phrase("Student Name"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        c1 = new PdfPCell(new Phrase("Total Time Worked"));
        c1.setHorizontalAlignment(Element.ALIGN_CENTER);
        table.addCell(c1);

        sumTimes();
        removeDuplicateStudents();
        addTotalTimeInfo(table);

        subCatPart.add(table);
    }

    //adds all student's work info into table
    private  void addWorkInfo(PdfPTable table) {
        for (Work w: workList) {
            table.addCell(w.getWorkId());
            table.addCell(w.getStudentName());
            table.addCell(String.valueOf(w.getStudentId()));
            table.addCell(w.getTaskName());
            table.addCell(w.getStartTime());
            table.addCell(w.getStopTime());
            table.addCell(w.getWorkTime()+" minutes");
        }
    }

    //adds all student's work info into table
    private  void addTotalTimeInfo(PdfPTable table) {
        for (Work w: totalTimeList) {
            table.addCell(String.valueOf(w.getStudentId()));
            table.addCell(w.getStudentName());
            table.addCell(w.getTotalWorkTime()+" minutes");
        }
    }


    //totals the minutes and seconds worked by each student
    private  void sumTimes() {
        int mins;
        int secs;
        String[] time;
        for(Work curStud: workList) {
            for(Work stud: workList) {
                if(curStud.getStudentId() == stud.getStudentId()) {
                    //concat until ':'
                    time = stud.getWorkTime().split("\\:");
                    mins = Integer.parseInt(time[0]);
                    secs = Integer.parseInt(time[1]);
                    curStud.setTotalMinutes(curStud.getTotalMinutes() + mins);
                    curStud.setTotalSeconds(curStud.getTotalSeconds() + secs);
                }
            }
        }
    }

    //removes any duplicate students from the list
    private  void removeDuplicateStudents() {
        //list used to have no duplicate students
        ArrayList<Work> modList;
        modList = workList;
        for (int i = 0; i < workList.size(); i++) {
            for (int j = i+1; j < workList.size(); j++) {
                if (modList.get(i).getStudentId() == workList.get(j).getStudentId()) {
                    modList.remove(j);
                    //reset j after removing an element
                    j = i;
                }
            }
        }
        totalTimeList = modList;
    }

    //sorts the workList by only including students in selected date range
    private  void sortByDateRange() throws ParseException {
        ArrayList<Work> rangeWorkList = new ArrayList<Work>();
        DateFormat format = new SimpleDateFormat("MMM dd, yyyy", Locale.US);
        Date start = format.parse(startDate);
        Date end = format.parse(endDate);
        Log.d("ExportToPdf","Created date obj" + start);
        Date studDate;
        //loop compares by date to determine if a student's work day is in range
        for (Work w: workList) {
            //put the date into a date object
            studDate = format.parse(w.getStopTime().substring(0,12));
            //adds students that worked in range(including start and end day) to new list
            if(studDate.equals(start) || studDate.equals(end)) {
                rangeWorkList.add(w);
            }
            else if(studDate.after(start) && studDate.before(end)) {
                rangeWorkList.add(w);
            }
        }
        //return sorted list to workList
        workList = rangeWorkList;
    }

    //adds a specified amount of whitespace
    private  void addEmptyLine(Paragraph paragraph, int number) {
        for (int i = 0; i < number; i++) {
            paragraph.add(new Paragraph(" "));
        }
    }

    public boolean isClockIns() {
        return clockIns;
    }

    public void setClockIns(boolean clockIns) {
        this.clockIns = clockIns;
    }
}




